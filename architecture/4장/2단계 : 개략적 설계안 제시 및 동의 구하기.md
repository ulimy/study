# 2단계 : 개략적 설계안 제시 및 동의 구하기

## 처리율 제한 장치는 어디에 둘 것인가?

### 클라이언트

> [ 클라이언트 / 처리율 제한장치 ]  ➡️ API 서버
>

- 일반적으로는 부적합한 위치일 수 있다.
- WHY?
    - 클라이언트의 요청은 손쉽게 위변조가 가능하다.
    - 모든 클라이언트의 구현에 제한 로직을 구현해야한다.

### 서버

> 클라이언트 ➡️   [ API 서버 / 처리율 제한장치 ]
>

### 미들웨어

> 클라이언트 ➡️ 미들웨어(처리율 제한 장치) ➡️ API 서버
>

- MSA의 경우 보통 API 게이트웨이에 구현된다.
- API 게이트웨이란?
    - 처리율 제한, SSL 종단, 사용자 인증, IP 허용 등을 담당하는 구성요소

### 어떤 요소를 고려하여 위치를 정해야할까?

- 기술 스택
    - 프로그래밍 언어 / 캐시 등 현재 사용하고있는 기술 스택 상 구현 가능한 곳을 확인한다.
- 필요한 알고리즘
    - 만약 서버측에 직접 구현할 수 있다면 알고리즘은 자유롭게 선택할 수 있다.
    - 제 3자에 의해 구현된 게이트웨이를 사용한다면 제한된 선택 내에 내가 필요한 알고리즘이 있는지 확인한다.
- 이미 존재하는 인프라
    - 이미 MSA를 사용하고 있고 API 게이트웨이가 있다면 해당 기능 또한 포함시켜야할 수 있다.
- 리소스
    - 리소스가 없다면 상용 API 게이트웨이를 사용할 수 밖에 없다.

## 처리율 제한 알고리즘

### 토큰 버킷 ( Token Bucket )

![Image](https://github.com/user-attachments/assets/293d6cfa-6fbd-4253-8ae9-e7c735ed8291)

- 동작원리
    - 하나의 요청은 하나의 토큰을 사용한다.
    - 버킷에 토큰이 있다면 하나를 꺼내 요청을 전달한다.
    - 버킷에 토큰이 없다면 요청은 버려진다.
- 고려사항
    - 버킷 크기
        - 몇개의 토큰을 담아놓을 것인가?
    - 토큰 공급률
        - 초당 몇개의 토큰을 공급할 것인가?
    - 버킷의 단위
        - API 단위
            - 통상적으로 많이 이용되는 단위이다.
            - 사용자마다 각 API 개수 만큼의 버킷이 필요하다.
            - EX) 하루 1개의 게시물 업로드 제한 , 하루 100개의 좋아요 제한 ⇒ 총 2개 버킷 필요
        - IP 단위
            - IP 주소마다 하나의 버킷이 필요하다.
        - 시스템 단위
            - 시스템의 처리율을 전체적으로 제한하고싶은 경우 사용할 수 있다.
            - 시스템당 하나의 버킷을 두어 모든 요청이 공유할 수 있도록 한다.
- 장점
    - 구현이 쉽고 메모리 사용량이 적다.
    - 뾰족한 트래픽이 들어오는 경우에도 일정한 양만 시스템에 도달하게된다.
- 단점
    - 버킷 크기 / 토큰 공급률의 적절한 조합을 튜닝하는 것이 어렵다.

### 누출버킷 ( Leaky Bucket )

![Image](https://github.com/user-attachments/assets/ae296b94-f452-45bd-adce-5495f862ded5)

- 동작원리
    - FIFO 큐를 통해 대부분 구현된다.
    - 각 요청이 들어오면 큐에 넣는다.
    - 큐가 가득 차있다면 요청은 버려진다.
- 고려사항
    - 버킷 크기 ( = 큐의 크기 )
        - 몇개의 요청을 담아놓을 것인가?
    - 처리율
        - 초당 몇개의 요청을 처리할 것인가?
- 장점
    - 큐의 크기가 제한되어있어 메모리를 효율적으로 사용한다.
    - 고정된 처리율을 가질 수 있다.
- 단점
    - 뾰족한 트래픽이 들어오는 경우 오래된 요청들만 쌓이고 최신 요청은 모두 버려진다.
    - 버킷(큐)의 크기 / 처리율의 적절한 조합을 튜닝하는 것이 어렵다.

### 고정 윈도 카운터 ( Fixed Window Counter )

![Image](https://github.com/user-attachments/assets/117f7934-bbd1-4fb0-a659-45ae15bb7a77)

- 동작원리
    - 시간을 고정된 크기의 윈도(window) 로 나눈다.
    - 각 윈도마다 카운터를 두어 요청이 들어올 때 마다 카운터 값을 증가시킨다.
    - 카운터 값이 임계치를 넘어가면 요청은 버려진다.
- 장점
    - 메모리 효율이 좋고 이해하기 쉽다.
    - 윈도우가 닫히는 시점에 트래픽을 재계산하기 때문에 특정한 트래픽 패턴이 있는 경우 적합하다.
- 단점
    - 윈도우 경계 부근에서 임계치보다 많은 트래픽이 들어올 가능성이 있다.

      ![Image](https://github.com/user-attachments/assets/a2c4ab49-3ef6-43d3-80e7-270d2d0de316)

        - 윈도는 00시 기준 1분( N:**00** - N+1:**00** ), 임계치를 5개로 설정했다고 가정한다.
        - 사진 속에서 2:00:**30** - 2:01:**30** 까지 들어온 트래픽은 10개이다.

### 이동 윈도 로그 ( Sliding Window Log )

![Image](https://github.com/user-attachments/assets/da023f7e-7abe-4131-88af-571940d90493)

- 동작원리
    - 각 요청이 들어온 타임스탬프를 추적한다. ( 이는 보통 캐시에 보관된다. )
    - 새 요청이 들어오는 시점에 만료된 요청을 제거한다.
    - 로그의 허용치를 넘어가면 요청은 버려진다.
    - 로그의 허용치가 1초당 2개의 요청이라고 가정 했을 때 그림의 예시를 살펴보면
        1. 로그가 비어있으므로 요청 허용
        2. 로그의 허용 한도보다 적으므로 요청 허용
        3. 로그의 허용 한도보다 크므로 요청 거부 및 타임스탬프 적재
        4. 1분이 지나 만료된 두개의 요청이 있으니 이를 제거하고, 로그의 허용 한도보다 적으므로 요청 허용
- 장점
    - 어느 순간의 윈도를 보더라도 처리율이 일정하다. 이는 고정 윈도 카운터의 단점이 보완되었음을 의미한다.
- 단점
    - 모든 요청의 타임스탬프를 보관하므로 메모리 사용량이 높다.

### 이동 윈도 카운터 ( Sliding Window Counter )

![Image](https://github.com/user-attachments/assets/7a7a4121-b19b-4be3-a84e-53fd73bd3d24)

- 동작원리
    - 고정 윈도 카운터와 이동 윈도 로그를 결합한 형태이다.
    - 현재 1분간의 요청 수 + ( 직전 1분간의 요청 수 * 이동 윈도와 직접 1분이 겹치는 비율 ) 을 계산한다.
    - 해당 값이 한도를 넘어가면 요청은 버려진다.
- 장점
    - 뾰족한 트래픽에도 일정한 처리량을 보장한다.
    - 특정한 값을 실시간으로 계산하여 사용하므로 메모리 효율이 좋다.
- 단점
    - 직전 1분간의 요청 수가 균등하다고 가정한 상태기 때문에 다소 느슨하다.
    - 하지만 클라우드플레어의 실험에 따르면 실제 상태와 맞지 않는 경우는 0.003%에 불과했다.

## 개략적인 구조

### 구조

- 위 알고리즘들의 구조는 모두 아래와 같이 단순하다.
    1. 추적 대상 별로 얼마나 많은 요청이 인입 되었는지를 측정하는 카운터를 둔다.
    2. 카운터가 특정 한도를 넘어가면 요청을 거부한다.
- 카운터는 어디에 보관하는 것이 좋을까?
    - 캐시이다.
    - 빠르고 시간을 기반한 만료 정책을 지원하기 때문이다.
    - 만약 레디스를 사용한다면 아래와 같은 명령어를 사용할 수 있다.
        - INCR : 카운터++
        - EXPIRE : 카운터에 TTL 설정

### 동작원리

![Image](https://github.com/user-attachments/assets/2c726be2-7e7c-4e72-af6f-aef4224522b1)

1. 클라이언트 ➡️ 미들웨어  : 요청 전송
2. 미들웨어 ➡️ 캐시 : 카운터 확인
3. 미들웨어 ➡️ API 서버 : 한도에 도달하지 않았다면 요청 전달