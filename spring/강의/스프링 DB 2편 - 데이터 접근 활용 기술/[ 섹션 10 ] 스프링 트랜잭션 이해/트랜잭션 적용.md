# 스프링의 트랜잭션 추상화

![image](https://github.com/user-attachments/assets/ef146b3f-37bb-4af3-a796-11503b7dbd06)

- 스프링은 트랜잭션을 추상화해서 제공하며, 실무에서 주로 사용하는 기술의 구현체도 제공한다.
- 스프링 부트는 어떤 기술을 사용하는지 자동으로 인식하여 스프링 빈으로 등록해준다.

# 트랜잭션 적용

### 스프링 트랜잭션 사용 방식

- 선언적 트랜잭션 방식 ( @Transactional )
    - 어노테이션 하나를 선언함으로써 트랜잭션을 편리하게 적용 및 관리한다.
    - 스프링 AOP를 기반으로 동작한다.
    - 매우 간편하고 실용적이기 때문에 대부분 이를 활용한다.
- 프로그래밍 방식
    - 트랜잭션 관련 코드를 직접 작성한다.
    - 애플리케이션 코드가 트랜잭션이라는 기술 코드와 강하게 결합된다는 단점이 있다.


### @Transactional의 작동 원리

1. 스프링 컨테이너에 프록시 객체가 등록된다.

   ![image](https://github.com/user-attachments/assets/860d396c-519f-482f-87ae-c096c4801274)

    - @Transactional 이 클래스/메서드에 하나라도 붙어있다면 트랜잭션 AOP는 프록시를 만들어 스프링 컨테이너에 등록한다.
    - 따라서 Autowired 등을 통해 의존관계 주입이 요청된다면, 프록시 객체가 주입된다.
    - 프록시 객체는 원래의 객체를 상속받은 형태로 만들어진다.


2. 메서드가 호출된다.
    - @Transactional이 붙어있는 메서드가 호출된 경우
        - 트랜잭션을 시작한다.
        - 실제 메서드를 호출한다. ( 상속관계이므로 부모 메서드 호출 가능 )
        - 트랜잭션을 커밋/롤백하여 종료한다.
    - @Transactional이 붙어있지 않은 메서드가 호출된 경우
        - 트랜잭션을 시작하지 않고, 실제 메서드를 호출한 뒤 종료한다.


### @Transactional의 2가지 규칙

- 우선순위
    - 스프링의 우선순위는 항상 구체적인 것이 우선순위가 높다.
    - 메서드/클래스 중 더 구체적인 것은 메서드이기 때문에, 메서드에 붙은 @Transactional이 우선순위가 높다.
    - 인터페이스/구현체 중 더 구체적인 것은 구현체이기 때문에, 구현체에 붙은 @Transactional이 우선순위가 높다.
    - (참고) 인터페이스에 @Transactional을 사용하는 것은 스프링의 AOP 적용 방식에 따라 인식되지 않을 수 있기 때문에 스프링 공식 메뉴얼에서 권장하지 않는다.
- 클래스에 적용하면 메서드는 자동적용
    - 클래스에 @Transactional이 붙어있는 경우 모든 메서드에 자동적용된다.
