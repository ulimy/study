### Cursor & Paging
> 대용량 데이터 처리 시, 성능/메모리 문제 해결을 위한 두가지 해결방안
>

- Cursor Based

  ![image](https://github.com/ulimy/study/assets/18046394/7aafea5a-b506-4c9d-97cd-85c5a91ac85f)

    - 현재 행에 커서를 유지하며 다음 데이터를 호출하면 다음 행으로 커서를 이동한다.

      ⇒ Streaming 방식

    - JDBC ResultSet
        - `next()` 메서드가 호출되어 데이터가 반환되고 객체와 매핑된다.
    - DB Connection이 연결되면 배치 처리가 완료될 때 까지 유지된다.
        - 현재를 기억하고, 계속해서 다음 데이터를 읽어와야하기 때문!

      ⇒ DB의 SocketTimeout을 충분히 큰 값으로 설정해야한다.

    - 모든 결과를 메모리에 할당했다가 하나씩 꺼내오도록 구현된 경우도 있기 때문에 메모리 사용량이 높다.
    - 커넥션 연결 유지 시간이 길고, 메모리 공간이 충분한 경우 적합한 방식이다.


- Paging Based

  ![image](https://github.com/ulimy/study/assets/18046394/e14e401a-93f1-4c58-ab78-5855e3ad6805)

    - 페이징 단위로 메모리에 가지고 온 뒤 한개씩 읽는다.
    - 한 페이지를 읽을때마다 커넥션을 맺고 끊는다.
    - 시작 행 번호를 지정하고(offset) , 한 페이지의 행의 수를 지정한다(limit).
    - 페이징 단위의 결과만 메모리에  할당하기 때문에 메모리 사용량이 낮아진다.
    - 커넥션 연결 유지 시간이 길지 않고, 메모리 공간을 효율적으로 사용해야하는 경우 적합한 방식이다.
