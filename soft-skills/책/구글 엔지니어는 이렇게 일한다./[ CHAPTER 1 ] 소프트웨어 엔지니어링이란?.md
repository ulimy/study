### [ CHAPTER 1 ] 소프트웨어 엔지니어링이란?

> 바위 위에 지어지는 것은 없습니다.
> 모든 것은 모래 위에 지어지죠.
> 하지만 우리는 모래가 바위라고 생각하고 지어야합니다.
>

- 프로그래밍과 소프트웨어 엔지니어링의 차이
    - 시간 / 규모 / 확장
    - 소프트웨어 엔지니어링은 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것이다.
    - 프로그래밍은 새로운 소프트웨어를 제작하는 수단이다.
    - 프로그래밍 ⇒ 개발
    - 소프트웨어 엔지니어링 ⇒ 개발 + 수정 + 유지보수


- 지속 가능성
    - 이 코드의 예상 수명을 생각해보자. 그렇다면 시간이 프로그램에 미치는 영향을 알 수 있게 된다.
    - 팀 조직, 프로젝트 구성, 정책, 관례 등은 소프트웨어 엔지니어링의 복잡성을 좌우한다.


- 시간과 변경
    - 소프트웨어 프로젝트의 기대 수명이 높다면 업그레이드의 중요도도 높다.

      ![image](https://github.com/ulimy/study/assets/18046394/0b4b8839-f25e-41ff-a1bb-ed563c31eb06)

        - 기대 수명의 최저점과 최고점 사이 어딘가에서 업그레이드 중요성의 전환이 일어난다.
        - 이를 기점으로 외부 환경에 대비하기 시작해야한다.
        - 정확한 전환 시점은 각자의 우선순위와 선호도에 따라 다르다. ( 대체로 5~10년 사이 )
    - 소프트웨어 프로젝트 업그레이드는 매우 고통스럽다.
        - 고통을 회피하지 말고, 고통을 덜어줄 방법을 찾자.
    - 수명이 길어질수록 `동작한다`와 `유지보수 가능하다`의 차이를 더 분명하게 인지해야한다.
    - 하이럼의 법칙

      > API 사용자가 충분히 많다면 API명세는 중요하지 않다.
      눈에 보이는 모든 행위를 누군가는 이용하게 될 것이다.
      >
        - 최선의 의도, 최고의 엔지니어, 꼼꼼한 코드 리뷰가 뒷받침 되더라도 명세를 완벽하게 구현했다고 단정할 수 없다.
        - 현실에서는 API 사용자가 명세에는 없는 기능을 찾아 활용하기도 한다.
        - 위의 기능이 널리 쓰이게 되면, 해당 API 변경이 점점 어려워진다.
    - 동작하는 것과 옳은 것은 다르다.
        - ex. HashSet에 값을 넣은 대로 직렬화됨을 가정하고 코드를 작성한다면 동작은 하겠지만 옳은 것일까?
        - API 명세에 명시되지 않은, 언제든 변할 수 있는 코드를 사용하는 것은 임시방편적이고 기발하다.
        - 모범사례를 따르고 미래에 대비한 코드는 클린하고 유지보수 가능하다.
        - 기발함이 칭찬으로 느껴진다면 프로그래밍이고, 질책으로 느껴진다면 소프트웨어 엔지니어링이다.
    - 그 시절 최적화된 기법이 여전히 유효하지 않을 수 있다.
        - 하드웨어의 변경 등으로 인해
        - 소프트웨어 설계도 제때 변경해주지 않으면 최신 하드웨어를 도입하는 효과가 퇴색된다.
        - 시스템에 문제가 없더라도 시간이 흐르면 변경을 진행할 이유가 자연스럽게 만들어지는 것이다.


- 규모 확장과 효율성
    - 끓는 물 속의 개구리
        - 규모 확장이 힘들어지고, 효율성이 떨어질 때 까지 서서히 눈치채지 못할 수 있다.
    - 갈아타기 규칙
        - 사용자들이 새 버전으로 옮기도록 돕거나, 직접 하되 하위 호환성을 유지한다.
        - 마이그레이션을 담당하는 전문가를 따로 둔다. ( 사용자가 대응할 필요 없도록 )
    - 개발 브랜치 사용하지 않기
        - 모든 팀과 모든 기능이 각각의 독립된 개발 브랜치로 나뉘는 경우
        - master로 병합할 때 동기화/테스트 등에 많은 시간을 허비하게 된다.
    - 비욘세 규칙

      > 네가 좋아했다면 CI 테스트를 준비했어야지!
      >
        - 인프라 변경을 안전하게 진행하게끔 보호해주는 정책이다.
        - 인프라가 변경되어 문제가 발생하는 경우, 같은 문제가 CI 에서 발견되지 않았다면 그것은 인프라팀의 책임이 아니다.
        - 인프라 팀은 각 팀의 코드변경을 쫓아다니며 테스트해줄 수 없다.
        - Why 비욘세?
            - 비욘세의 히트곡 Single Ladies 네가 좋아했다면 반지를 끼워줬어야지 라는 가사에서 유래되었다.
            - 코드를 짰으면 자기 코드에 대한 테스트도 자기가 만들었어야지!
    - 원점 회귀

      > 왼쪽으로 옮기는 행위
      >
        - 문제를 일찍 발견할수록 비용이 적게 든다.

          ![image](https://github.com/ulimy/study/assets/18046394/c4c78902-fae6-4fea-b32d-decda748ea5d)

        - 커밋 전 정적 검사나 코드리뷰로 찾아낸 버그는 배포 이후에 발견한 버그보다 훨씬 싸게 고친다.
        - 가능한 많은 버그를 왼쪽에서 잡자!


- 트레이드 오프와 비용
    - 내가 시켰으니까 방식을 지양한다.
        - 한 명의 결정권자를 두고 의사결정하지 않는다.
        - 잘못된 결정이라 판단될 때 찾아가야할 사람들의 에스컬레이터 경로는 정의하지만, 이는 독재가 아니라 합의를 도출하기 위해 존재한다.
    - 의사 결정을 위한 근거자료
        1. 관련 데이터를 측정/추정 할 수 있는 경우
            - nice !
        2. 측정하기 어렵거나, 측정할 수 없는 경우
            - 절충안을 찾기 위해 선례, 경험, 리더십 등에 기대야한다.

      ⇒ 모든 것이 측정 가능하지 않다는 사실을 인정하고, 그런 결정에도 똑같은 우선순위와 관심을 두자.

    - 빌드 시간
        - 코드베이스가 커져가며 빌드 시간도 증가한다.
        - 빌드 시간의 증가는 일할 시간의 감소를 의미한다. ( 엔지니어의 멍때리는 시간 증가 )
        - 분산 빌드 도입
            - 빌드 시간을 줄이기 위해 자체 분산 빌드 시스템을 개발했다.
            - 빌드 시간은 빨라졌지만, 엔지니어 각자가 빌드 시간 단축에 신경쓰지 않게 되었다.
            - 이는 불필요한 의존성 추가 등으로 인해 자원을 무분별하게 사용하게 되었다.

          ⇒ 제번스의 역설 : 효율이 좋아지면 자원소비가 늘어난다.

    - 시간과 규모 확장 사이에서 결정하기

      > 우리 팀에만 해당하는 문제가 생겼어. 의존성을 추가할까? fork 하거나 다시 구현할까?
      >
        1. fork
            - 장점 : 외부 솔루션에 의존하지 않고 온전히 내가 통제할 수 있다.
            - 단점 : 확장성과 지속 가능성에 위협이 생긴다.

              ⇒ fork된 코드의 원본에 수정이 일어난 경우 fork 되어있는 모든 코드를 수정해야한다.

        2. 의존성 추가
            - 장점 : 코드에 수정이 일어난 경우, 한 부분만 수정하면 된다.

      ⇒ 일관성이 주는 가치는 아주 크지만, 범용적이게 만드는 비용도 만만치않다.
