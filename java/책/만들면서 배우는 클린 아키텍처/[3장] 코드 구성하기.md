### [3장] 코드 구성하기

- 계층으로 구성하기

  ![image](https://github.com/ulimy/study/assets/18046394/b1012f68-71fd-47d9-bade-538c4cb7091f)

    - 기능조각, 특성으로 구분짓는 패키지 경계가 없다.
    - 애플리케이션이 제공하는 유스케이스를 파악하기 어렵다.
    - 어떤 기능이 어디서 어떻게 호출되는지 한눈에 알아보기 힘들다.
 

- 기능으로 구성하기

  ![image](https://github.com/ulimy/study/assets/18046394/0257f3e0-4847-4cfc-9698-e96f6c9e8df4)

    - 하나의 기능을 코드에서 한번에 알아볼 수 있다.
    - 모든 코드가 하나의 패키지에 있음으로써 계층방식보다 가시성이 떨어진다.
        - 어댑터가 무엇인지 한눈에 알 수 없다.


- 표현력 있는 패키지 구조 사용하기

  ![image](https://github.com/ulimy/study/assets/18046394/076d6a40-271d-4eb8-89a4-045781447e39)

    - 구조의 각 요소들은 패키지 하나씩에 직접 매핑된다.
        - `account`: Account와 관련된 유스케이스를 구현한 모듈임을 나타낸다.
        - `domain`: 도메인 모델이 속한 패키지
        - `application`:  도메인 모델을 둘러싼 서비스 계층을 포함한다.
        - `adaptor`: 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와, 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다.
    - 패키지에 들어있는 모든 클래스는 application 패키지 내의 인터페이스를 통하지 않고는 외부에서 호출되지 않기 때문에 접근제어자를 package-private으로 설정할 수 있다.
    - DDD 개념에 직접 대응시킬 수 있다.
    - 완벽한 방법은 존재하지 않다. 하지만, 표현력 있는 패키지 구조는 적어도 코드와 아키텍처 간의 갭을 줄일 수 있게 해준다.


- 의존성 주입의 역할

  ![image](https://github.com/ulimy/study/assets/18046394/31d5ccef-992a-466f-94d6-1a9ec7e5d8ca)

    - 인커밍 어댑터는 제어흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같아서 쉽다.
        - ex) Controller에서 application 계층의 위치한 서비스 호출
    - 아웃고잉 어댑터는 제어흐름의 방향이 역전될 수 있도록 의존성 역전 원칙을 사용해야한다.
        - 애플리케이션에 아웃고잉을 위한 인터페이스를 만들고 어댑터에 이를 구현한 클래스를 두는 것!
