### [ CHAPTER 11 ] 테스트 개요

- 테스트의 가치
    - 테스트는 엔지니어에게 신뢰를 줄 때만 가치다 있다.
    - 테스트가 생산성을 떨어뜨리고 결과를 믿을 수 없다면 아예 없느니만 못하다.
    - 문제가 터진 후에야 테스트를 고민해서는 안된다. 결험은 막대한 금전적 손실을 일으킬 수 있다.


- 구글 웹 서버 이야기
    - 구글 웹 서버의 규모가 커지면서 릴리즈 때마다 버그가 넘쳐났고, 다음 릴리즈까지의 기간도 길어졌다.
    - 이를 위해 자동 테스트 정책 도입!
    - 도입 후 핫픽스가 절반으로 줄었다.
    - 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안된다.
        - 디버깅에 의존한다면, 자동테스트와 비교했을 떄 비용차이가 크다.


- 오늘날의 개발 속도에 맞는 테스트
    - 대부분의 소프트웨어는 기능와 지원 플랫폼이 매우 많기 때문에 사람이 모든 것을 수동으로 검증할 수 없다.
    - 이를 위한 해법이 자동화!


- 작성하고, 수행하고, 조치하라
    - 테스트를 작성하는 것과 좋은 테스트를 작성하는 것은 별개이다.
    - 자동테스트의 핵심은 같은 동작을 끊임없이 반복하는(실행하는) 데에 있다. ⇒ CI
    - 테스트를 코드로 작성한다면 다양한 환경에서 수행할 수 있도록 모듈화 할 수 있다.
        - 파이어폭스, 크롬 등 브라우저가 달라지는 경우에도 수행 가능!
    - 테스트 프로세스가 얼마나 효과적이냐는 테스트 실패를 어떻게 처리하냐에 달려있다.
        - 처리 없이 쌓여만 간다면 테스트에 투자한 노력이 허사가 된다.
    - 모두가 작성하고, 공유하고, 정기적으로 실행하고, 바로 조치하라.


- 테스트코드가 주는 혜택
    - 기능 구현에 드는 시간만큼 ( 혹은 그 이상 ) 테스트 작성에 써야하니, 생산성이 높아진다는 생각을 못할 수 있다. 하지만!
    - 디버깅 감소
        - 커밋 전 테스트가 깨져 결함 위치를 확인할 수 있다.
    - 자신있게 변경
        - 테스트가 있으니 변경을 수용할 수 있고, 자연스럽게 리팩터링이 권장된다.
    - 더 나은 문서자료
        - 한번에 하나의 행위만 검증하는 테스트코드는 마치 실행 가능한 문서의 역할을 한다.
        - 요구사항이 변경되어 기존의 테스트가 동작하지 못한다면, 해당 문서가(테스트가) 낡았음이 증명된다.
    - 더 단순한 리뷰
        - 리뷰어가 해야하는 검증의 영역을 줄여준다. ( 정확성, 극단적인 상황, 오류 상황 등등 )
    - 사려 깊은 설계
        - 테스트하기 어렵다면, 너무 많은 역항르 짊어지거나 의존성이 복잡할 가능성이 크다.
    - 고품질의 릴리즈를 빠르게
        - 릴리즈에 불안이 감소되었기에, 더 빠르게 릴리즈할 수 있다.


- 테스트 크기 설계하기

  > 테스트 크기란? 테스트 케이스 하나를 실행하는데 필요한 자원
  >
    - 작은 테스트
        - 프로세스 하나에서 동작한다.
        - 테스트를 느려지게 하거나, 비결정적으로 만드는 것을 방지하기 위해
            - 서버를 따로 두고 테스트를 연결해 수행하는 것도 허용되지 않는다.
            - sleep, I/O Blockin을 호출하는 등 네트워크와 디스크에 접근할 수 없다. ( 만약 필요하다면 테스트 대역을 이용한다. )
    - 중간 테스트
        - 기기 하나에서 동작한다.
        - 테스트 대상을 현실적인 설정 하에서 검증하기 위해
            - 여러 프로세스를 두거나, 네트워크와 디스크 접근 도 허용한다.
            - 하지만 외부 시스템과의 통신은 허용하지 않는다. ( 최소한의 보호막 역할 )
    - 큰 테스트
        - 자원을 원하는 만큼 사용하여 동작한다.
        - 그만큼 위험도 늘어나니 용도를 한정해야한다.
            - ex. E2E 테스트 ⇒ 코드 조작이 아닌, 설정을 검증하는 것이 주된 목적이다.
        - 큰 테스트는 작은/중간 테스트와 분리되어 빌드/릴리즈 시에만 수행되어야한다.
    - 공통 특성
        - 모든 테스트는 밀폐되어야한다.
            - 셋업 / 실행 / tear down 까지 모든 정보를 담고있어야한다.
        - 확인하려는 행위를 수행하는데 필요한 정보만! 담고있어야햔다.
            - 불필요한 정보가 많다면 실패 원인을 진단하거나 리뷰 등이 어려워진다.
        - 조건문이나 순환문같은 제어문을 쓰지 않아야한다.
            - 테스트가 복잡해질수록 버그가 생길 가능성이 커지며, 실패 원인을 찾기 어려워진다.
        - 테스트는 실패할 때만 다시 들여다 보게되며, 작성되는 수보다 읽히는 수가 훨씬 많다.

          ⇒ 누군가가 읽었을 때 부끄럽지 않도록 작성하자.


- 테스트 범위 설계하기

  > 테스트 범위란? 테스트 케이스 하나가 검증하는 코드의 양 ( 실행 X 검증 O )
  >
    - 좁은 범위 테스트
        - 독립된 클래스, 메서드와 같이 일부 로직 검증
    - 중간 범위 테스트
        - 컴포넌트 사이의 상호작용 검증
        - 기능테스트, E2E 테스트, 시스템 테스트 등
    - 넓은 범위 테스트
        - 서로 다른 부분들의 상호작용, 조합 테스트
    - 이상적인 비율

      ![image](https://github.com/ulimy/study/assets/18046394/29171b84-cbdd-4344-a69e-2bad7e97d939)

    - 비이상적인 비율
        - 아이스크림 콘 패턴 : 느리고, 신뢰할 수 없다.

          ![image](https://github.com/ulimy/study/assets/18046394/ee98c985-daaf-4efc-8a09-f47378fbbb37)

        - 모래시계 패턴 : 중단 범위 테스트로 더 빠르고 쉽게 해결할 것을 넓은 범위 테스트로 막아내고있다.

          ![image](https://github.com/ulimy/study/assets/18046394/e57f90b6-1ae7-4a53-9b40-ac6bfc70ceb3)


- 비욘세 규칙
    - 어떤 것을 테스트할까? 깨뜨려보고 싶은 모든 것을 테스트하라.
    - 시스템이 실패할 때를 기다리는 것은 어리석다. 미리 테스트를 작성하자.


- 코드 커버리지
    - 적은 수의 테스트로 많은 라인을 실행시키지만, 의미 있는 동작은 없을 수 있다.
    - 커버리지 자체를 목표로 삼지 말자.
    - 검사해야하는 행위가 아니라, 검사해야하는 대상에 집중해야한다!


- 구글 규모의 테스트
    - 구글은 모든 코드를 모노레포에서 관리한다.
    - 모든 코드는 head에 직접 커밋되어 모두가 즉시 볼 수 있다.
    - 함정
        - 모의객체 오용
        - 테스트 수행시간 증가
    - 해결방안
        - 테스트를 존중하는 문화 ( 잘 짜면 보상, 성능 목표 설정, 리팩터링 )
        - 문서 자료 보강 등 안좋은 테스트를 만드는 실수를 줄이기


- 자동 테스트를 전사로 뿌리내리게 한 원동력
    - 오리엔테이션 수업
        - 입사 오리엔테이션에서 테스트의 이점을 다뤄, 마치 구글의 표준 관행인 것 처럼 교육한다.
    - 테스트 인증 프로그램
        - 자신의 테스트 프로세스 수준을 5개의 레벨로 구분한다.
        - 레벨이 높아질수록 어려운 조건이 추가된다.

          ⇒ 실패하는 테스트 없어야 릴리즈 가능, 비결정적인 테스트 제거 등

    - 화장실에서도 테스트
        - 화장실의 칸칸마다 테스트 개선법을 알리는 짧은 글을 붙인다.


- 자동테스트의 한계
    - 느낌을 검증하거나, 창의력이 필요한 분야에서는 인간의 테스트가 더 뛰어날 수 있다.
    - 탐색적 테스팅
        - 사람이 검증하고, 이를 시스템에 추가하는 것
        - 검사 대상을 마치 고장내야할 처즐로 취급한다.

          ⇒ 일부러 엉뚱한 데이터를 입력하거나, 예상치 못한 절차로 실행
